# 3장 - 역할,책임,협력
2장에서는 클래스, 추상클래스, 인터페이스를 조합하여 객체지향 프로그램을 구조화하는 방법을 알아봤다 <br>
상속,합성, 다형성을 구현하는 기법또한 알아봤다 <br>

다형성은 동적 바인딩 메커니즘을 통해 구현된다는 것도 알았고, 상속은 코드를 재사용하기 좋지만 <br>
캡슐화 측면에서 단점이 있어, 합성 이라는 것을 사용한다는 것도 알았다 <br>

유연한 객체지향 프로그램을 위해서는 컴파일 의존성 과 실행 시간 의존성이 달라야한다는 것을 알았다<br>

객체지향 패러다임의 관점에서 핵심은 **'역할' , '책임', ' 협력'** 이다 <br>
객제지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다 <br>
객제치향 설계 핵심은 협력을 구성하기 위해 적절한 객체를 찾고, 적절한 책임을 할당하는 과정에서 드러난다 <br>

#### 클래스 상속,인터페이스,추상화는 객체들의 역할,책임,협력이 자리잡은 후에 사용하는 구현 메커니즘일 뿐이다
 
코드가 역할,책임,협력에 대한 role 이 없다면 응집도 높은 클래스와 중복 없는 상속 계층을 구현하더라도 애플리케이션의 품질은 좋지 않을 것이다 <br>

## 협력
객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **'협력'** 이라고 한다 <br>
객체가 협력에 참여하기 위해 수행하는 로직은 **'책임**' 이라고 부른다 <br>
그리고 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. <br>

객체지향 시스템은 자율적인 객체들으 공동체 이다 <br>
객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적인 존재이다 <br>

협력은 객체지향으 세계에서 기능을 구현할 수 있는 유일한 방법이다 <br>
두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도음을 요청 할 때 시작된다 <br>

메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다 <br>
객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문에 오직 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다 <br>

협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다 <br>
한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다 <br>

즉, 두 객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다 <br>
객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다 <br>

메시지를 수신한 객체는 '메소드' 를 실행해 요청에 응답한다 <br>

자율적인 객체란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체이다 <br>
객체의 자율성을 보장하기 위해서는 필요한 정보와 정보에 기반한 행동을 같은 객체 안에 모아놓아야 한다 <br>

객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는 것이다 <br>
캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다 <br>

캡슐화를 통해 직접적인 접근을 막고, 메시지(=메소드)를 통한 협력(=접근)을 요청한 후에 객체 변경을 허용하게 해야한다 <br>

### 협력이 설계를 위한 문맥을 결정한다.
객체지향은 객체를 중심에 놓는 프로그래밍 패러다임이다 <br>
여기서 객체란 상태와 행동을 함께 캡슐화 하는 실행 단위다 <br>
그렇다면 객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야 할까? <br>

객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다 <br>
협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다 <br>
협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다 <br>

상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다 <br>
결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다 <br>
```java
public class Movie {
    private Money fee; // 상태
    private DiscountPolicy discountPolicy; // 상태
    
    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}

```

## 책임
### 책임이란 무엇인가
객체를 설계하기 위해 필요한 문맥인 협력이 갖춰졌다고 하자 <br>
다음으로 할 일은 협력에 필요한 행동을 수행할 수 있는 적절한 객체를 찾는 것이다 <br>
이 때 협력에 참여하기 위해 객체가 수행하는 행동을 **'책임'** 이라고 부른다 <br>

객체의 책임은 객체가 무엇을 알고 있는가(knowing), 무엇을 할 수 있는가(doing) 로 구성된다 <br>

#### doing
- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것

#### knowing
- 사적인 정보에 관해 아는 것
- 관련된 객체에 관해 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것


책임은 객체지향 설계의 핵심이다 <br>
객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정한다 <br>
객체의 구현 방법은 상대적으로 책임보다는 덜 중요하며 책임을 결정한 다음에 고민해도 늦지 않다 <br>

CRC 카드 이론을 생각해서 정리를 하면서 개발을 하자 <br>
글로 정의를 해놓고 개발을 하면 인터페이스 및 책임, 협력 등 사이즈가 잡힐 것이다 <br>

위 CRC 카드를 활용하여 절차지향 기법 대신 객체지향 설계에 적용할 수 있는 구체적이고 실재적인 재료가 될 것이다 <br>

### 책임 할당
객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의해야 한다 <br>
객체가 책임을 수행하게 하는 유일한 방법은 메시지를 전송하는 것이므로 책임을 할당한다는 것은 메시지의 이름을 결정하는 것과 같다 <br>
협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다 <br>

### 책임 주도 설계
어떤 책임을 선택하느냐에 따라 전체적인 설계의 방향과 흐름을 결정한다 <br>
RDD 책임주도설계 라는 말이 있다 <br>
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다 <br>

책임 주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있게 한다 <br>
구현이 아닌 책임에 집중하는 것이 중요한 이유는 유연하고 견고한 객체지향 시스템을 위해 가장 중요한 재료가 바로 책임이기 때문이다 <br>

#### 메시지가 객체를 결정한다
메시지가 객체를 선택해야 하는 이유?
- 객체가 최소한의 인터페이스를 가질 수 있게 된다.
- 객체는 추상적인 인터페이스를 가질 수 있게 된다.

인터페이스는 무엇을(What) 해야하는지만 표현해야 하지, 어떻게(How)는 노출할 필요가 없다 <br>

#### 행동이 상태를 결정한다.
객체가 존재하는 이유는 협력에 참여하기 위해서다 <br>
메시지를 받고, 객체는 협력에 필요한 행동을 제공해야 한다 <br>

객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다 <br>
캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다 <br>

중요한 것은 객체의 상태가 아니라 "행동" 이다. <br> 

## 역할과 협력
객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 '역할' 이라고 부른다 <br>
실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는게 좋다 <br>

추상 클래스와 인터페이스는 동일한 책임을 수행하는 다양한 종류의 클래스들을 협력에 참여시킬 수 있는 확장 포인트를 제공한다 <br>
협력 안에서 역할이 어떤 책임을 수행해야 하는지를 결정하는 것이 중요하다. 역할을 구현하는 방법은 그 다음 문제이다 <br>

객체에게 중요한 것은 행동이며, 역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출수 있게 한다 <br>

### 유연하고 재사용 가능한 협력
역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다 <br>
역할을 구현하는 것은 추상화라는 것을 알아야 한다 <br>

동알헌 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합하는 방법은 '추상화' 이다 <br>
추상화를 구현하는 가장 일반적인 방법은 '추상 클래스 & 인터페이스' 이다 <br>

협력의 관점에서 추상 클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것이다 <br>
추상 클래스는 책임의 일부를 구현해 놓은 것, 인터페이스는 구현 없이 책임의 집합만을 나열해 두었다는 차이가 있다 <br>

### 객체 대 역할?
객체에 관해 생각할 때 '이 객체가 무슨 역할을 수행해야 하는가?' 라고 자문하는 것이 도움이 된다 <br>

### 역할과 추상화
추상화를 이용하면 중요한 정책을 상위 수준에서 단순화 할 수 있다, 그리고 설계가 좀 더 유연해진다 <br>
역할은 다양한 환경에서 다양한 객체들을 수용할 수 있게 해주므로 협력을 유연하게 만든다 <br>

연극 배우가 여러 연극에 참여하면서 여러 배역을 연기할 수 있는 것처럼 객체 역시 여러 협력에 참여하면서 다양한 역할을 수행할 수 있다 <br>
객체는 여러 역할을 가질 수 있지만, 특정한 협력 안에서는 일시적으로 오직 하나의 역할만이 보여진다는 점에 주의해야 한다 <br>

### 정리
객체지향의 핵심은 역할, 책임, 협력이다 <br>
음,, 아직 100% 이해가 가지는 않는다 <br>

이해가 갈듯? 말듯 아직은 애매한 상태임..실무에서 또한 추상화를 고려하며 항상 개발을 하고 있다 <br>
CRC카드 기법을 잘 이용하여 개발 하는 습관을 가질 필요가 있어 보인다