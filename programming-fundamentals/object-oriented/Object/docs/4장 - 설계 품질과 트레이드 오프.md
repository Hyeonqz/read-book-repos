# 4장 설계 품질과 트레이드 오프
객체지향 설계의 핵심은 역할,책임,협력이다 <br>
협력은 어플리케이션 기능을 구현하기 위해 메시지를 주고 받는 객체들 사이의 상호작용 이며, 책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동이고, 역할은 대체 가능한 책임의 집합이다 <br>

책임 주도 설계에서는 '책임' 을 중심으로 객체지향 설계를 진행한다 <br>

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다 <br>
- 객체지향 설계의 핵심은 '책임' 이다
- 책임을 할당하는 작업이 응집도와 결합도와 같은 설계 품질과 깊이 연관돼 있다.

결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙은 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다 <br>

### 데이터 중심의 영화 예매 시스템
상태를 분할의 중심축으로 삼는 방법과 책임을 분할의 중심축으로 삼는 방법이 있다 <br>
데이터 중심의 관점은 객체의 상태에 초점을 맞추고, 책임 중심의 관점은 객체의 행동에 초점을 맞춘다 <br>

훌륭한 객체지향 설계는 데이터가 아니라 '책임' 에 초점을 맞춰야 한다. 그 이유는 변경과 관련이 있다. <br>
객체의 상태는 구현에 속한다. 구현은 불안정하기 때문에 변하기 쉽다 <br>

- 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너짐
  - 상태 변경은 인터페이스 변경을 초래하며, 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게 됨.
- 객체의 책임은 인터페이스에 속한다.
  - 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다.
  - 즉 책임에 초점을 맞추면 상대적으로 안정적인 설계를 얻을 수 있다.

## 데이터 중심 설계를 해보자
```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DiscountCondtion> discountCondtions;

    private MovieType movieType;
    private Money discoutnAmount;
    private double discountPercent;
}

```
위 클래스는 할인 조건 인터페이스가 변수로 정의되어 있다, 그리고 할인 금액,퍼센트가 변수로 정의되어 있다. <br>

데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중한다 <br>

객체지향의 가장 중요한 원칙은 캡슐화 이므로 내부 데이터가 객체의 엷은 막을 빠져나가 외뷔의 다른 객체들을 오염시키는 것을 막아야 한다 <br>
이를 달성할 수 있는 가장 간단한 방법은 '접근자' 및 '수정자' 를 추가하는 것이다 <br>

```java
@Setter
@Getter
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DiscountCondtion> discountCondtions;

    private MovieType movieType;
    private Money discountAmount;
    private double discountPercent;
}
```

순수 java 에는 없지만, 라이브러리 Lombok 을 사용해 Getter,Setter 를 사용할 수 있게 되었다 <br>

데이터 중심의 설계는 할인 조건의 목록이 인스턴스 변수로 Movie 안에 직접 포함돼있다 <br>

좋은 설계의 특징을 판단할 수 있는 기준은 캡슐화, 응집도, 결합도 를 기준으로 판단을 해보자 <br>

### 캡슐화
상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위함이다 <br>
구현은 보통 나중에 변경될 가능성이 높은 어떤 것을 가리킨다 <br>

객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급 효과를 적절하게 조절이 가능하다 <br>

객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제한다 <br>

변경될 가능성이 높은 부분을 **구현**, 상대적으로 안정적인 부분은 **인터페이스** 라고 부른다 <br>

객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다 <br>
객체지향의 가장 중요한 원리는 '캡슐화' 이다 <br>
외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류이다 <br>

객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는 것이다 <br>
복잡성을 다루기 위한 효과적인 도구는 '**추상화**' 이다 <br>

요구사항은 자주 변경이 된다. 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 영향을 통제할 수 있다 <br>

정리하면 캡슐화는 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다 <br>

### 응집도와 결합도
응집도 -> 모듈에 포함된 내부 요소 들이 연관돼 있는 정도 <br>
모듈 내의 요소들이 하나의 목적을 위해 협력한다면 그 모듈은 높은 응집도를 가진다 <br>

결합도 -> 의존성의 정도를 나타내며, 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도이다 <br>
어떤 모듈이 다른 모듈에 대해 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다 <br>

일반적으로 좋은 설계는 높은 응집도와 낮은 결합도를 의미한다 <br>
좋은 설게란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계 이다 <br>
그 과정에 높은 응집도와 낮은 결합도가 있으며, 이는 변경과 관련되어 있다 <br>

변경의 관점에서 응집도란 '변경 발생시 모듈 내부에서 발생하는 변경의 정도' 로 측정할 수 있다 <br>
응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다 <br>

변경의 관점에서 결합도 또한 '변경 발생시 모듈 내부에서 발생하는 변경의 정도'로 측정할 수 있다 <br>
결합도가 높으면 영향을 받는 대상이 많아지기에 코드 변경이 어렵다 <br>

직접 작성한 코드의 경우는 항상 불안정하며 언제라도 변경될 가능성이 높다 <br>

캡슐화의 정도가 응집도와 결합도에 영향을 미친다 <br>
캡슐화를 지키면 모듈안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다 <br>

데이터 중심의 설계는 캡슐화를 위반하고 객체의 내부 구현을 인터페이스의 일부로 만든다 <br>
반면 책임 중심의 설계는 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화 한다 <br>

어떠한 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거다 -> SRP <br>

### 캡슐화를 지키자
객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다 <br>
객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메소드를 통해서만 상태에 접근할 수 있어야 한다 <br>

객체에게 의미 있는 메소드는 객체가 책임져야 하는 무언가를 수행하는 메소드 이다 <br>
private 으로 설정했다고 해도, 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다 <br>

캡슐화를 강화하는 좋은 방법은 도메인 메소드를 만드는 것이다 <br>
```java
public class Rectangle {
    private long right;
    private long bottom;
    
    // 캡슐화를 지킬 수 있는 메소드
    public void enlarge(long multiple) {
        this.right *= multiple;
        this.bottom *= multiple;
    }
}

```

Rectangle 을 변경하는 주체를 외부 객체에서 본인으로 옮겼다 <br>
즉 자신이 직접 상태를 변경할 수 있도록 책임을 이동시켰다 <br>
이 뜻이 바로 객체가 자기 스스로를 책임진다는 말의 의미다 <br>


### 스스로 자신의 데이터를 책임지는 객체









