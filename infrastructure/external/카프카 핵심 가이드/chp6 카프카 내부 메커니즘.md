# 6장 카프카 내부 메커니즘
이 장에서는 카프카를 실제로 사용하는 사용자 입장에서 특히 중요한 주제에 초점을 맞출 것이다 
- 카프카 컨트롤러
- 카프카에서 복제가 동작하는 방식
- 카프카가 프로듀서와 컨슈머의 요청을 처리하는 방식
- 카프카가 저장을 처리하는 방식

위 4가지 주제들은 카프카를 튜닝할 때 특히 도움이 된다 <br>
위 부분을 알게되면 아무렇게나 설정을 바꾸는게 아닌, 명확한 의도를 가지고 설정값을 잡아주는 데 큰 도움이 된다 <br>

## 6.1 클러스터 멤버쉽
기존 Zookeeper의 역할을 전담하는 Controller 노드들이 Raft 합의 알고리즘을 통해 메타데이터를 관리하였다 <br>
3개 또는 5개의 Controller 노드로 구성된 Quorum이 형성되며, 이 중 하나가 Active Controller로 선출됩니다 <br>
Controller들은 __cluster_metadata라는 내부 토픽에 모든 메타데이터 변경사항을 이벤트 로그 형태로 기록하였다  <br>

하지만 zookeeper 가 제거되고 현재는 kraft 를 사용하는 버전에서는 다른 식으로 관리를 진행한다 <br>

## 6.2 컨트롤러
컨트롤러는 일반적인 카프카 브로커의 기능에 더해서 파티션 리더를 선출하는 역할을 추가적으로 맡는다 <br>
ex) 브로커01(컨트롤러), 브로커02, 브로커03 <br>

브로커가 컨트롤러가 되면 클러스터 메타데이터 관리와 리더 선출을 시작하기 전에 먼저 최신 레플리카 상태 map 을 읽어온다 <br>

KRaft 이후 부터는 주키퍼 프로세스가 없어졌기에 카프카 프로세스 외에 다른 프로세스는 없다 <br>
다만 카프카 프로세스가 컨트롤러, 브로커 2개 중 하나의 역할을 가지게 된다
- 컨트롤러: 카프카 클러스터의 동적 메타데이터를 저장하는 역할
  - 1개 이상의 프로세스가 하나의 쿼럼을 구성하며, 이들 중에서 저장된 데이터의 업데이트 및 조회 작업을 담당하는 프로세스를 액티브 컨트롤러라고 한다
- 브로커: 카프카 데이터를 저장하는 역할
  - 하나의 컨트롤러 쿼럼을 사용하는 브로커들이 모여 하나의 클러스터를 이룬다.

KRaft 이후의 컨트롤러는 동적 메타데이터를 저장하는 역할을 하는 카프카 프로세스를 가리킨다 <br>

Kafka KRaft에서 Controller Quorum은 메타데이터 관리를 책임지는 Controller 노드들의 그룹이다 <br>
```text
1. 브로커가 "새 토픽 생성" 요청 → Leader Controller에 전달

2. Leader Controller
   - 메타데이터 변경을 로그에 기록
   - Follower Controller들에게 복제 요청

3. Quorum 합의
   - 3개 이상의 Controller가 로그 복제 완료
   - Leader가 "커밋 완료" 선언

4. 모든 브로커에 변경사항 전파
```

1. 고가용성 보장

Controller 1개가 죽어도 나머지가 즉시 새 Leader를 선출합니다 <br>
Zookeeper가 필요했던 이유와 동일하지만, 이제는 Kafka 자체가 해결합니다

2. 데이터 일관성 유지

과반수(Majority)가 동의해야만 메타데이터 변경이 확정됩니다 <br>
5개 노드 중 최소 3개가 동의해야 합니다 (5/2 + 1 = 3)

3. Split-Brain 방지

네트워크 분할 시 과반수를 가진 그룹만 계속 작동합니다 <br>
소수 그룹은 자동으로 서비스를 중단하여 데이터 충돌을 방지합니다

> Controller Quorum = Kafka의 자체 합의 그룹

- Zookeeper 없이도 메타데이터를 안전하게 관리
- Raft 알고리즘으로 Leader 선출 및 로그 복제
- 과반수 합의로 일관성 보장


## 6.3 복제
복제는 카프카 아키텍쳐의 핵심이다 <br>
실제로 카프카는 '분산', '분할', 복제된 커밋 로그 서비스로 표현되기도 한다 <br>
복제가 중요한 이유는 개별적인 노드에 필연적으로 장애가 발생할 수밖에 없는 상황에서 카프카가 신뢰성과 지속성을 보장하는 방식이기 때문이다. <br>

카프카에 저장되는 데이터는 토픽 단위로 해서 조직화 된다 <br>
각 토픽은 1개 이상의 파티션으로 분할되며, 각 파티션은 다시 다수의 레플리카를 가질 수 있다 <br>

각각의 레플리카는 브로커에 저장되는데, 대개 하나의 브로커는 수백 ~ 수천개의 레플리카를 저장한다 <br>

레플리카의 종류는 2가지가 있다
- 리더 레플리카
  - 각 파티션에는 리더 역할을 하는 레플리카가 하나씩 있다.
  - 일관성을 보장하기 위해 모든 쓰기 요청은 리더 레플리카가 진행한다.
- 팔로워 레플리카
  - 리더 레플리카를 제외한 모든 파티션은 팔로워 레플리카 이다.
  - 별도 설정이 없으면 팔로워는 클라이언트 요청을 처리할 수 없다.
  - 이들이 하는 역할은 리더 레플리카로 들어온 메시지를 복제함으로써 최신 상태를 유지하는 것이다.

만약 파티션의 리더 레플리카가 크래쉬가 날 경우, 팔로워 레플리카 중 하나가 파티션의 새 리더 파티션으로 승격된다 <br>

팔로워 레플리카가가 읽기 작업을 하려면 client.rack 컨슈머 설정값을 잡아 주어, 가까운 컨슈머에서 값을 읽게 처리할 수 있다 <br>

리더 역할 레플리카가 수행하는 또 다른 일은 어느 팔로워 레플리카가 리더 레플리카의 최신 상태를 유지하고 있는지 체크하는 것이다 <br>
팔로워 레플리카는 새로운 메시지가 도착하는 즉시 리더 레플리카로부터 모든 메시지를 복제해 옴으로써 최신 상태를 유지할 수 있도록 한다 <br>
하지만 어느 이유에서 동기화가 깨질 수도 있다 <br>

리더 레플리카와의 동기화를 유지하기 위해 팔로워 레플리카들은 리더 레플리카에 읽기 요청을 보낸다 <br>
위 요청은 컨슈머가 메시지를 읽기 위해 사용하는 요청이기도 하다 <br>

- out-of-sync-replica (OSR)
  - 팔로워 레플리카가 리더 레플리카를 따라가는데 실패하였을 경우 -> 장애 상황에서 리더가 될 수 없음
    - 추후 리더를 따라 잡게 되면 ISR 로 복귀 가능함
- in-sync-replica (ISR)
  - 지속적으로 최신 메시지를 요청하고 있는 경우 -> 장애 시 리더가 될 수 있음.

## 6.4 요청 처리
카프카 브로커가 하는 일의 대부분은 클라이언트, 파티션 레플리카, 컨트롤러가 파티션 리더에게 보내는 요청을 처리하는 것이다 <br>
카프카는 TCP로 전달되는 이진 프로토콜을 가지고 있다 <br>

모든 요청은 아래 내용을 포함하는 표준 헤더를 가진다.
- 요청 유형: API Key
- 요청 버전: 브로커는 서로 다른 버전의 클라이언트로부터 요청을 받아 각각의 버전에 맞는 응답을 한다.
- Correlation ID: 각 요청의 고유 식별자 -> 트러블 슈팅에 사용
- 클라이언트 ID: 요청을 보낸 어플리케이션을 식별하기 위해 사용

### 6.4.1 쓰기 요청
acks 설정 매개변수는 쓰기 작업이 성공한 것으로 간주되기 전 메시지에 대한 응답을 보내야 하는 브로커의 수를 가리킨다 <br>
어느 시점에서 메시지가 성공적으로 쓰여졌다 라고 간주되는지는 프로듀서 설정을 통해 바꿀 수 있다
```text
acks=1: 리더만 메시지를 받을 경우
acks=all: 모든 in-sync-replica 들이 메시지를 받았을 때
acks=0: 메시지가 보내졌을 때, 브로커 응답을 기다리지 않음.
```

파티션의 리더 레플리카를 가지고 있는 브로커가 해당 파티션에 대한 쓰기 요청을 받게 되면 몇 가지 유효성 검증을 진행한다
- 데이터를 보내고 있는 사용자가 토픽에 대한 쓰기 권한이 있는지?
- 요청에 지정된 acks 설정값이 올바른지? (0,1,all 만 사용 가능)
- acks=all 일 경우 메시지를 안전하게 쓸 수 있을 만큼, 충분히 in-sync-replica 가 있는지?

그러고 나서 브로커는 새 메시지들은 로컬 디스크에 쓴다 <br>
리눅스의 경우 메시지는 파일 시스템 캐시에 쓰여지는데, 이들이 언제 디스크에 반영될지는 보장이 없다 <br>
카프카는 데이터가 디스크에 저장될 때 까지 기다리지 않는다. 메시지의 지속성을 위해 복제에 의존한다 <br>

메시지가 파티션 리더에 쓰여지고 나면, 브로커는 acks 설정에 따라 응답을 내려보낸다 <br>
0,1 이면 바로 응답을 내려보내고, all 이면 in-sync-replica 에 복제가 된 것을 확인 한 후에 응답을 준다 <br>

### 6.2 읽기 요청
클라이언트는 브로커에 토픽, 파티션 그리고 오프셋 목록에 해당하는 메시지들을 보내 달라는 요청을 보낸다 <br>
ex) test 토픽의 파티션0 오프셋53~60 까지 메시지를 보내주세요 <br>

































