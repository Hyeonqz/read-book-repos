# 가상 메모리
메모리 관리 기법인 스와핑과 메모리에 프로세스를 할당하는 방식, 그리고 연속 메모리 할당의 부작용인 외부 단편화에 대해 알아보자 <br>

현재는 메모리 내에 프로세스들이 연속적으로 배치되는 상황을 가정해 보았다 <br>
프로세스에 연속적인 메모리 공간을 할당하는 방식을 '연속 메모리 할당' 방식 이라고 한다 <br>

### 스와핑
메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 있을 수도 있다 <br>
I/O 작업 중 대기 상태인 프로세스나 오랫동안 사용되지 않은 프로세스들이 속한다 <br>
위 프로세스들을 임시 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리 상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 '스와핑' 이라고 한다 <br>

이때 프로세스들이 쫓겨나는 보조기억장치의 일부 영역을 '스왑 영역' 이라고 한다 <br>
현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨 지는 것을 '스왑 아웃' 이라고 하며, 반대로 스왑 영역 프로세스 -> 메모리 로 옮기는 것을 '스왑 인' 이라고 부른다 <br>

스왑 아웃 -> 스왑 인 으로 바뀔 떄는 기존의 물리 주소와는 다른 주소에 적재될 수 있다 <br>

스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있습니다 <br><br>

## 1) 메모리 할당
#### 최초 적합
os 가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간 발견시 그 공간에 프로세스를 배치하는 방식임 <br>
프로세스가 적재될 공간을 발견시 즉시 메모리를 할당한다 -> 검색 최소화 및 메모리 빠른 할당 <br>

#### 최적 적합
os 가 빈 공간 모두 검색 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식 <br>

#### 최악 적합 
os 가 빈 공간 모두 검색 후, 프로세스가 적재될 공간 중 가장 큰 공간에 프로세스를 배치하는 방식 <br><br>

### 외부 단편화
연속 메모리 할당은  '외부 단편화' 라는 문제를 내포하고 있다 <br>
메모리를 크게 나누면, 커널 영역, 사용자 영역 2개로 나뉘고, 프로세스는 사용자 영역에 적재된다 <br>
커널 영역은, os 가 실행될 때 필요한 프로세스(및 스레드)가 적재된다 <br>

외부 단편화는 프로세스를 할당하기 어려울만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상을 의미한다 <br>

실제 서버에서는 적재되는 프로세스도 많고 나가는 프로세스도 많기 때문에 외부 단편화로 인해 낭비되는 공간은 더욱 크다 <br>
외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 압축 하는 방법이 있다 <br>

하지만 압축 방식에는 단점이 있다 <br>
작은 빈 공간들을 하나로 모으는 동안, 시스템은 하던일을 중지해야하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기한다 <br>
위 문제를 해결하기 위해서 나온 방법이 지금까지 사용되는 '페이징 기법' 이다 <br><br>


## 2) 페이징을 통한 가상 메모리 관리
가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다 <br>
위를 가능케 하는 가상 메모리 관리 기법에는 크게 '페이징' 과 '세그먼테이션'이 있다 <br>

현재 대부분의 가상 메모리를 사용한다면 페이징 기법을 사용하고 있을 것이다 <br>
페이징 기법 사용시 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만 아니라 '외부 단편화' 문제도 해결할 수 있다 <br>

연속 메모리 할당 방식에서 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다 <br>

페이징은 프로세스의 논리 주소 공간을 페이지 라는 **일정한 단위**로 자르고, 메모리 물리 주소 공간을 **프레임** 이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당 하는 가상 메모리 관리 기법이다 <br>

페이징에서 스왑핑을 사용할 수 있다. 프로세스 전체가 스왑 아웃/인 되는 것이 아닌 페이지 단위로 스왑/아웃 인 이 된다 <br>
즉 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃되고, 실행에 필요한 페이지들은 메모리로 스왑 인 되는 것이다 <br>

즉 메모리에 적재될 필요가 없는 페이지들은 보조 기억장치로 스왑 아웃 되고, 실행에 필요한 페이지들은 메모리로 스왑인 되나 <br>
즉 프로세스 내에서 페이징을 시킨다는 뜻이다 <br>

즉, 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다 <br>
프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 필요하지 않은 페이지들은 보조 기억장치에 남겨둔다 <br>

### 페이지 테이블
프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다 <br>
프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU 모두 알고 있기란 어렵다, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 '다음에 실행할 명령어 위치' 를 찾기 어려워진다 <br>

이를 해결하기 위해 페이징 시스템은 메모리 물리 주소에 불연속적으로 배치되더라도, CPU 가 바라보는 논리 주소에는 연속적으로 배치되도록 '**페이지 테이블**' 기법을 이용한다 <br>

페이지 테이블은, 페이지 번호와 프레임 번호를 짝 지어주는 일종의 이정표 라고 생각하면 된다 <br>
CPU 는 페이지 번호를 이용해 페이지가 적재된 프레임을 찾을 수 있다 <br>

페이지 테이블은 프로세스의 물리 주소 와 논리 주소를 이어주는 중간 매개체 라고 생각하면 된다 <br>

추가적으로 페이징은 외부 단편화 문제를 해결하지만, '내부 단편화' 라는 문제를 야기할 수도 있다 <br>
내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생한다 <br>

프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다 <br>

페이지 테이블을 메모리에 두면 문제가 있다 <br>
메모리 접근 시간이 2배로 늘어난다. 위 문제를 해결하기 위해 CPU 곁에 TLB 라는 페이지 테이블의 캐시 메모리를 둔다 <br>

#### 페이징의 이점 - 쓰기 시 복사
외부 단편화 문제를 해결한다는 점 이외에도 페이징이 제공하는 이점은 다양하다 <br>
대표적으로는 프로세슷 간에 페이지를 공유할 수 있다는 점이다 ex) 쓰기 시 복사 <br>

멀티 프로세스에서 프로세스 fork 하여 동일한 프로세스 2개가 복제되면 코드 및 데이터 영역을 비롯한 모든 자원이 복제되어 메모리에 적재된다 <br>
프로세스 간에는 기본적으로 자원을 공유하지 않는다 <br><br>

## 3) 페이지 교체와 프레임 할당
#### 요구 페이징
프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법 <br>
요구 페지이 시스템이 안정적으로 작동하려면 필연적으로, '페이지 교체' 및 '프레임 할당' 문제를 해결해야 한다 <br>

요구 페이징 기법으로 적재하다보면 메모리가 가득차게 된다 <br>
이때는 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다 <br>
메모리에 적재된 많고 많은 페이지중 어떤 페이지를 내보내는게 좋을까? <br>

이를 결정하는 방법이 바로 '페이지 교체 알고리즘' 이다 <br>

### 페이지 교체 알고리즘
일반적으로 페이지 폴트를 가장 적에 일으키는 알고리즘을 좋은 알고리즘으로 평가한다 <br>
페이지 폴트가 일어나면 보조기억장치로부터 필요한 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문이다 <br>

#### FIFO
Queue 와 같은 개념이다. 먼저 올라온 페이지부터 먼저 나간다 <br>
+ 추가적으로 2차 기회 페이지 교체 알고리즘 또한 존재한다 <br>

#### 최적 페이지 교체 알고리즘
CPU 에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘 이다 <br>
보조 기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지이므로, 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 심는 것이 가장 합리적이다 <br>

최적페이지 교체 알고리즘은 가장 낮은 페이지 폴트를 보장하는 알고리즘이다 <br>
다만 위 알고리즘은 실제 구현이 어렵다 <br>

#### LRU 페이지 교체 알고리즘
가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘 <br>


### 스래싱과 프레임 할당
프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생한다 <br>

프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하야 성능이 저해되는 문제를 스래싱 이라고 한다 <br>

스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다 <br>