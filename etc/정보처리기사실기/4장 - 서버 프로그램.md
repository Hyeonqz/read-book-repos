## 4장 서버 프로그램 구현

### 아키텍쳐 패턴
#### 레이어 패턴
시스템을 계층으로 구분하여 구성 ex) OSI 7 Layer
#### 클라이언트 서버 패턴
하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
#### 파이프 필터 패턴
데이터 스트림 절차의 각 단게를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
#### 모델 뷰 컨트롤러
MVC 패턴

객체지향 구성 요소 : 객체, 클래스, 메시지<br>
객체지향의 특징 : 캡슐화, 상속, 다형성, 연관성

객체지향 분석 방법론
1) 럼바우 : 객, 동, 기
- 객체 모델링 : 객체 다이어그램
- 동적 모델링 : 상태 다이어그램
- 기능 모델링 : DFD 자료흐름도 이용
2) Booch 방법
3) Jacobson 방법
4) Coad 와 Yourdon 방법

객체지향 설계 원칙 (SOLID)
1) 단일 책임 원칙(SRP) -> 객체는 단 하나의 책임만 가진다.
2) 개방 폐쇄 원칙(OCP) -> 기존의 코드 변경 없이 기능을 추가할 수 있도록 설계한다.
3) 리스코프 치환 원칙(SLP) -> 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다.
4) 인터페이스 분리 원칙(ISP) -> 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받으면 안된다.
5) 의존 역전 원칙(DIP) -> 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

### 결합도
모듈 간의 상호 의존하는 정도 <br>
내 공 외 제 스 자<br>
결합도가 강할 수록 품질이 낮고, 결합도가 약할수록 품질이 좋다
- 내용 결합도 : 한 모듈이 다른 모듈의 내부 기능을 직접 참조 (결합도 가장 높음 -> 쓰레기)
- 공통 결합도 : 파라미터가 아닌 모듈 밖에 선언된 전역변수를 사용하여 갱신
- 외부 결합도 : 모듈에서 선언한 변수를 외부의 다른 모듈에서 사용한다
- 제어 결합도 : 다른 모듈 내부의 논리적인 흐름을 제어한다
- 스탬프 결합도 : 모듈간 인터페이스로 배열,자료구조 가 전달된다.
- 자료 결합도 : 모듈 간 인터페이스가 자료 요소로만 구성될 때의 결합도 이다. (결합도 가장 낮음 -> 좋음)

### 응집도
모듈의 내부 요소들이 서로 관련된 정도<br>
기 순 교 절 시 논 우 (우 논 시 절 통 순 기) <br> 
응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다.<br>
좋은 소프트웨어는 결합도가 낮고, 응집도가 높은것을 의미한다<br>

- 기능적 : 모듈 내부의 모든 기능요소 들이 단일 문제와 관련 (응집도 가장 강함 -> 좋음)
- 순차적 : 모듈 내 활동으로부터 출력 데이터를 다음 활동 데이터로 사용한다.
- 통신적 : 동일한 입출력 사용하여 서로 다른 기능을 수행
- 절차적 : 모듈안의 기능들이 순차적으로 수행할 때
- 시간적 : 특정 시간에 처리되는 몇개의 기능을 모아 모듈로 작성할 경우
- 논리적 : 유사한 성격을 갖는 요소들을 하나의 모듈로 형성
- 우연적 : 모듈 내 서로 관련 없는 요소로만 구성된 경우 (응집도 가장 약함 -> 쓰레기)

Fan-in -> 모듈이 받는 노드을 개수 <br>
fan-out -> 

IPC <br>
모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합 <br>

### 디자인 패턴
모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 <br>
생성 - 구조 - 행위 패턴으로 분류가 된다.

#### 생성 패턴 (추,빌 팩,프 싱)
1) 추상 팩토리 (Abstract Factory)
- 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
2) 빌더 
- 작게 분리된 인스턴스를 건축 하듯이 조합하는 것
3) 팩토리 메소드 
- 상위 클래스에서 인터페이스만 정의하고, 실제 생성은 서브 클래스가 담당한다. (가상 생성자 패턴)
4) 프로토타입
- 원본 객체를 복제하는 방법, 객체를 생성하는 패턴이다.
5) 싱글톤
- 클래스 내에서 인스턴스가 하나뿐임을 보장 -> 불필요한 메모리 낭비를 최소화 할 수 있다.

#### 구조 패턴 (어 브 컴 데 퍼 플 프)
1) 어댑터 (Adapter)
- 호환성이 없는 클래스 들의 인터페이스를 다른 클래스가 이용하게 끔 변환
2) 브리지 (Bridge)
- 구현부에서 추상층을 분리하여 서로가 독립적으로 확장 가능
3) 컴포지트 (Composite)
- 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
4) 데코레이터 (Decorator)
- 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
5) 퍼싸드 (Facade)
- Wrapper 객체 필요, 서브 클래스 들 사이의 통합 인터페이스를 제공한다.
6) 플라이웨이트 (Flyweight)
- 인스턴스가 필요할 때 마다 매번 생성하는 것이 아니고, 가능한 공유해서 메모리 절약
7) 프록시 (Proxy)
- 복잡하 시스템을 개발하기 쉽도록 클래스ㅏ 객체들을 조합하는 패턴 (대리자)


#### 행위 패턴
1) 책임 연쇄 (Chain of Responsibility)
- 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못한다면 다음 객체로 넘어가는 형태
2) 커맨드 (Command)
- 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장
3) 인터프리터 (Interpreter)
- 언어에 문법 표현을 정의하는 패턴
4) 반복자 (Iterator)
- 자료구조와 같이 접근이 잦은 객체에 동일한 인터페이스 사용
5) 중재자 (Mediator)
- 많은 객체들 간의 복잡한 상호작용을 캡슐화 하여 객체로 정의하는 패턴
6) 메멘토 (Memento)
- 특정 시점에서의 객체 내부 상태를 객체화 함으로써 이후 요청에 따라 객체를 해당 시점으로 돌린다
7) 옵저버 (Observer)
- 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
- 주로 분산 시스템 간 이벤트 생성, Publish, Subscribe 할 때 이용
8) 상태 (State)
- 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
9) 전략 (Strategy)
- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
10) 템플릿 메소드(Template Method)
- 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴.
11) 방문자 (Visitor)
- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴이다.





















































































