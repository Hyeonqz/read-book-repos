# CPU 스케줄링 알고리즘
cpu 스케줄링 알고리즘의 종류는 매우 다양하고 os 마다 다른 스케줄링 알고리즘을 사용하고 있다 <br>

### 선입 선처리 스케줄링
선입 선처리 스케줄링은 FCFS 스케줄링 이라고도 부릅니다 <br>
이는 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식입니다 <br>

먼저 요청한 프로세스 부터 cpu 를 할당하는 방식으로, 매우 공정해 보이지만 <br>
os 에 세계에서 효율적인 방법은 아니다 <br>

말 그대로 제일 먼저 들어온 프로세스가 제일 오래 걸리는 프로세스 라면? <br>
뒤에 들어온 프로세스는 cpu 점유시간이 적든, 뭐든 상관없이 계속 '대기 상태' 로 cpu 할당을 기다려야 한다 <br>

여기서 생각나는 말이 군대 시절에 "꼬우면 군대 빨리 오든가?" 라는 말이 생각 났습니다 <br>

위처럼 짧은 점유를 하지만, 오래 기다리는 현상을 '**호위 효과**' 라고도 합니다 <br>

### 최단 작업 우선 스케줄링(SJF)
호위 효과를 방지하기 위해서 나타난 알고리즘 기법입니다 <br>

말 그대로 준비 큐에 삽입된 프로세스들 중에서 CPU 이용 시간이 가장 짧은 프로세스 부터 실행하는 방식이다 <br>
SJF 스케줄링 이라고도 불린다 <br>

### 라운드 로빈 스케줄링
선입 선처리 스케줄링에 타임 슬라이스 라는 개념이 더해진 스케줄링 방식이다 <br>
**타임 슬라이스** 란 각 프로세스가 CPU 를 사용할 수 있는 정해진 시간을 의미한다 <br>

즉 라운드 로빈 스케줄링은 타임 슬라이스 만큼 시간 동안 돌아가며 CPU 를 이용하는 선점형 스케줄링 방식이다 <br>
큐에 삽입된 프로세스들은 삽입된 순서대로 CPU 를 이용하되 정해진 시간만큼만 CPU 를 이용하고, 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 <br>
다시 대기 큐 맨 뒤에 삽입된다, 이때 바로 문맥 교환이 발생한다 <br>

라운드 로빈 스케줄링 에서는 타임 슬라이스 크기가 매우 중요하다 <br>
타임 슬라이스가 크면 FCFS 스케줄링이랑 별다르게 없고, 너무 작으면 문맥교환이 자주 일어나 오버헤드가 발생할 수 있다 <br>
결국 프로세스가 다 끝나지 않고 PCB 에 다시 저장하는 과정에서 문맥교환이 발생하는 것이니 프로세스가 다 끝날 수 있게 타임 슬라이스를 정하는게 좋다 <br>

### 최소 잔여 시간 우선 스케줄링
SRT 스케줄링 이라고도 불리며, SJF 스케줄링 + RR 스케줄링 방식을 합친 방식이다 <br>

즉 정해진 타임 슬라이스 만큼만 CPU 를 할당받아 사용하되, 프로세스 중 가장 작업시간이 적은 프로세스 부터 cpu 를 할당받는다 <br>
나는 이게 최적의 알고리즘이라고 생각했다 <br>

### 우선순위 스케줄링
우선순위 스케줄링은 말 그대로 프로세스들에게 우선순위를 부여하고, 가장 높은 우선순위 부터 cpu 를 할당받자는 알고리즘이다 <br>
(우선순위가 같은 프로세스 들은 선입 선처리로 스케줄링 된다) <br>

앞에서 설명한 최단 작업 우선 스케줄리은 작업 시간이 짧은 프로세스에 높은 우선 순위를 부여하는 방식이고 <br>
최소 잔여 시간 우선 스케줄링은 시간이 짧은 프로세스에 높은 우선순위를 매기는 **'우선순위 스케줄링'** 이다 <br>

우선순위 스케줄링은 근본적인 문제를 가지고 있습니다 <br>
높은 우선순위 부터 실행하니, 우선순위가 낮은 프로세스들은 무한정 대기를 할 수 밖에 없습니다 <br>
이 현상을 **'기아'** 현상 이라고 합니다 <br>

우선순위가 높은 프로세스만 계속 먼저 실행되니, 우선순위가 낮은 프로세스는 당연히 실행이 계속 뒤로 밀리게 된다는 것이다 <br>

이를 방지하기 위한 대표적인 기법으로 '에이징' 이 있습니다 <br>
이 방법은 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다 <br>

말하자면 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법입니다 <br>

### 다단계 큐 스케줄링
우선순위 스케줄링의 발전된 형태이다 <br>
우선순위 별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다 <br>

이렇게 큐를 여러개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다 <br>
그리고 큐마다 스케줄링 기법을 다르게 할필요가 있다면 그 것또한 가능하다 <br>

준비 큐 별로 타임 슬라이스를 여러 개 지정하고, 다른 스케줄링 알고리즘을 사용하여, 처리가 가능하다는 이점이 있다 <br>

### 다단계 피드백 큐 스케줄링
다단계 큐 스케줄링의 발전된 형태이다 <br>
다단계 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 없다<br>

그러나 이런 방식대로라면 우선순위가 낮은 프로세스는 계속 연기될 여지가 있다 <br>
'기아' 현상이 또 발생할 수 있다 <br>

언제 높은 우선순위의 프로세스가 들어올지 모르므로, 우선순위가 낮은 프로세스 입장에서는 매우 불리할 것이다 <br>
이를 보완한 스케줄링 알고리즘이 '**다단계 피드백 큐 스케줄링**' 이다 <br>

위 스케줄링은 프로세스들이 큐 사이를 이동할 수 있다는 점이 있다 <br>

타임 슬라이스 시간 동안 실행을 다 못끝냈으면 다른 큐로 이동해서 작업을 마치 끝낼 수도 있다는 뜻이다 <br>

즉 CPU 를 비교적 오래 사용해야하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU 를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝난다 <br>

낮은 우선순위를 가지고 준비 큐에서 너무 오래기다리고 있다면 점차 우선순위를 높이고(=에이징 기법) 높은 큐로 이동시켜 기아 현상을 예방할 수 있다 <br>

다단계 피드백 큐 스케줄링은 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘 이다 

### 핵심 포인트
- 선입 선처림 스케줄링: 준비 큐에 삽입된 순서대로 CPU를 할당한다.
- 최단 작업 우선 스케줄링: 준비 큐에 삽입된 프로세스들 중 CPU 사용 시간의 길이가 가장 짧은 프로세스부터 CPU를 할당한다
- 라운드 로빈 스케줄링: 정해진 시간만큼 돌아가며 CPU를 할당한다.
- 우선순위 스케줄링: 가장 높은 우선순위를 가진 프로세스에 CPU를 할당한다.
- 다단계 큐 스케줄링: 우선순위 스케줄링 발전된 형태 준비큐가 여러개 이다.
- 다단계 피드백 큐 스케줄링: 프로세스들이 여러개의 준비 큐 사이를 이동할 수 있다.